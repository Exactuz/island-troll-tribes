package WeaponsOfChoice

// Standard library imports:
import BuffObjEditing
import ChannelAbilityPreset
import ClosureEvents
import ClosureTimers
import HashMap
import LinkedList

// Local imports:
import ColorUtils
import LocalObjectIDs
import LocalAssets
import IdListConstant
import UnitExtensions
import CustomItemType
import PlayerExtensions
import HashList
import AxeThrow
import EquipmentSlots
import Transformation
import SingleMindedFury
import LocalObjectIDs2


let TT_WEAPONS_OF_CHOICE = "Gurubashi Warrior gains different abilitites depending on weapons he has equipped:\n"+
                            "\n{0} - Axe Throw".format("One-handed weapon".color(COLOR_GOLD_STR))+
                            "\n{0} - Whirlwind".format("Two-handed weapon".color(COLOR_GOLD_STR))+
                            "\n{0} - Shield Charge, replaces Spiked Net".format("Shield".color(COLOR_GOLD_STR))+
                            "\n{0} - Whirling Axes; replaces Spiked Net".format("Two weapons".color(COLOR_GOLD_STR))

public let weaponsOfChoiceAbilitites = new HashList<int>()
    ..add(ABILITY_AXE_THROW)
    ..add(ABILITY_WHIRLWIND)
    ..add(ABILITY_SPIKED_NET)
    ..add(ABILITY_WARRIOR_SHIELD_CHARGE)
    ..add(ABILITY_AXE_THROW_DW)
    ..add(ABILITY_WHIRLING_AXES)
    ..add(ABILITY_WEAPONS_OF_CHOICE)
    ..add(ABILITY_SINGLE_MINDED_FURY)

@compiletime function createTitansGripAbility()
    new AbilityDefinitionAttackSpeedIncrease(ABILITY_TITANS_GRIP)
        //..setMovementSpeedBonus(1, 0)
        ..setAttackSpeedIncrease(1, 0)
        ..setItemAbility(true)
        ..setName("Titan's Grip")
        ..setEditorSuffix("(Wurst)")

public let ABILITY_TITANS_GRIP_BUFF = compiletime(
    createDummyBuffObject(
        "Titan's Grip".color(COLOR_GREEN),
        "Allows you to use two-handed weapons in one hand",
        Icons.pASBTNSeaGiantPulverize
    ).abilId
)

@compiletime function createNightStalkerDummyAbility()
    new AbilityDefinitionEvasion(ABILITY_WEAPONS_OF_CHOICE)
        ..setChancetoEvade(1, 0.)
        ..setLevels(1)
        ..presetButtonPosNormal(3, 2)
        ..setTooltipNormal(1, "Weapons of Choice")
        ..setIconNormal(LocalIcons.pASBTNWeaponsOfChoice)
        ..setTooltipLearn("Weapons of Choice")
        ..setTooltipLearnExtended(TT_WEAPONS_OF_CHOICE)
        ..setTooltipNormalExtended(1, TT_WEAPONS_OF_CHOICE)

public class WeaponsOfChoice
    unit troll
    real attackDamage
    bool isSuperSub
    AxeThrow axeThrowInstance
    LinkedList<item> inventory
    IterableMap<int, bool> abilities = new IterableMap<int, bool>()
    static HashMap<unit, thistype> instances = new HashMap<unit, thistype>()

    construct(unit troll)
        this.troll = troll
        axeThrowInstance = new AxeThrow(troll, this)
        axeThrowInstances.put(troll, new AxeThrow(troll, this))
        instances.put(troll, this)
        nullTimer() ->
            initializeAbilityMap()
            updateAbilities()          

    static function onSub(unit troll)
        if WeaponsOfChoice.getInstance(troll) != null
            return
        new WeaponsOfChoice(troll)

    static function getInstance(unit troll) returns thistype
        return WeaponsOfChoice.instances.get(troll)

    static function updateItems(unit troll, item itm)
        if not EQUIPMENT_LIST.has(itm.getTypeId()) and not itm.getTypeId() == ITEM_HUNTER_TROPHY_FANG
            return
        let instance = getInstance(troll)
        if instance == null
            return
        instance.updateAbilities()

    static function onRevive(unit troll)
        let instance = getInstance(troll)
        if instance == null
            return
        instance.updateAbilities()

    function initializeAbilityMap()
        for abilId in weaponsOfChoiceAbilitites
            abilities.put(abilId, false)
            troll.disableAbility(abilId, true, true)


    function updateAbilities()
        resetAbilities()
        updateAbilityMap()
        for abilId in abilities
            if abilities.get(abilId) == true
                troll.disableAbility(abilId, false, false)

    function resetAbilities()
        for abilId in abilities
            if abilities.get(abilId) == true
                abilities.put(abilId, false)
                troll.disableAbility(abilId, true, true)

    function updateAbilityMap()
        inventory = troll.getInventory()
        let singleMindedFuryInstance = SingleMindedFury.instances.get(troll)
        let equippedItems = troll.getOwner().getEquippedItems()
        inventory.addAll(equippedItems)
        if isSuperSub
            singleMindedFuryInstance.isEnabled = true
            abilities.put(ABILITY_SINGLE_MINDED_FURY, true)
        abilities.put(ABILITY_SPIKED_NET, true)        
        if hasAxe()
            abilities.put(ABILITY_SPIKED_NET, true)
            abilities.put(ABILITY_AXE_THROW, true)

        if hasTwoHandedWeapon()
            singleMindedFuryInstance.isEnabled = false
            abilities.put(ABILITY_SINGLE_MINDED_FURY, false)
            abilities.put(ABILITY_WHIRLWIND, true)
            abilities.put(ABILITY_SPIKED_NET, true)
            if not isSuperSub   
                abilities.put(ABILITY_AXE_THROW, false)
            else
                abilities.put(ABILITY_AXE_THROW, true)

        if isDualWielding()
            abilities.put(ABILITY_SPIKED_NET, false)
            abilities.put(ABILITY_AXE_THROW, true)
            //abilities.put(ABILITY_AXE_THROW_DW, true)
            abilities.put(ABILITY_WHIRLING_AXES, true)

        if hasShield()
            abilities.put(ABILITY_SPIKED_NET, false)
            abilities.put(ABILITY_WARRIOR_SHIELD_CHARGE, true)

        int count = 0
        for each in abilities
            if abilities.get(each) == true
                count+=1
        if count <3
            abilities.put(ABILITY_WEAPONS_OF_CHOICE, true)            

        destroy inventory
        destroy equippedItems


    function isDualWielding() returns bool
        int axeCount = 0
        for each in inventory
            if AXE_LIST.has(each.getTypeId())
                axeCount+=1
                if axeCount >=2
                    return true
        return false

    function hasTwoHandedWeapon() returns bool
        for each in inventory
            if TWO_HANDED_WEAPON_LIST.has(each.getTypeId())
                return true
        return false

    function hasShield() returns bool
        for each in inventory
            if SHIELD_LIST.has(each.getTypeId())
                return true
        return false

    function hasAxe() returns bool
        for each in inventory
            if AXE_LIST.has(each.getTypeId())
                return true        
        return false

    static function onSuperSub(unit troll)
        let instance = instances.get(troll)
        if instance == null
            return
        if instance.troll.getTypeId() != UNIT_JUGGERNAUT
            return
        instance.troll.addAbility(ABILITY_TITANS_GRIP_BUFF)
        instance.troll.makeAbilityPermanent(ABILITY_TITANS_GRIP_BUFF, true)
        instance.isSuperSub = true
        nullTimer() -> 
            instance.updateAbilities()

    function updateDamage()
        var itemsDamageBonus =0
        let inventory = troll.getInventory()
        let equippedItems = troll.getOwner().getEquipmentSlots().currentItems
        for each in equippedItems
            let damageBonus = CustomItemType.getInstance(equippedItems.get(each).getTypeId()).damageBonus
            itemsDamageBonus+=damageBonus
        for each in inventory
            let damageBonus = CustomItemType.getInstance(each.getTypeId()).damageBonus
            itemsDamageBonus+=damageBonus
        attackDamage = (troll.getBaseDamage(0)+itemsDamageBonus).toReal()
        destroy inventory

    function getAttackDamage() returns real
        updateDamage()
        return attackDamage

init
    EventListener.onCast(ABILITY_WARRIOR) (unit caster) ->
        WeaponsOfChoice.onSub(caster)

    EventListener.add(EVENT_PLAYER_UNIT_PICKUP_ITEM) -> 
        WeaponsOfChoice.updateItems(GetManipulatingUnit(), GetManipulatedItem())

    EventListener.add(EVENT_PLAYER_HERO_REVIVE_FINISH) ->
        WeaponsOfChoice.onRevive(GetTriggerUnit())

    registerOnEquipEvent(EQUIPMENT_CALLBACK_ANY) (unit troll, item itm) ->                  
        WeaponsOfChoice.updateItems(troll, itm) 

    registerAfterEffect() (unit target, int unitID) ->
        WeaponsOfChoice.onSuperSub(target)

    EventListener.add(EVENT_PLAYER_UNIT_DROP_ITEM) ->
        let u = GetManipulatingUnit()
        let itm = GetManipulatedItem()
        nullTimer() -> 
            WeaponsOfChoice.updateItems(u, itm) 

    registerOnUnequipEvent(EQUIPMENT_CALLBACK_ANY) (unit troll, item itm) ->                  
        WeaponsOfChoice.updateItems(troll, itm)        