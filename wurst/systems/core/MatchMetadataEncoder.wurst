package MatchMetadataEncoder

// Standard library imports:
import HashSet
import LinkedList
import RegisterEvents
import StringBuilder

// Third-party imports:

// Local imports:
import Game
import GameStates
import MatchMetadataConfig
import MatchMetadataObjectIds
import PlayerExtensions
import Tribe
import UnitExtensions

constant real ENCODE_INTERVAL = 0.05
constant int MATCH_CHECKSUM_MOD = 1000000007

public class MatchPlayerMetadata
    int slotIndex
    string name
    string raceCode
    int team
    string result

    construct(int slotIndex, string name, string raceCode, int team, string result)
        this.slotIndex = slotIndex
        this.name = name
        this.raceCode = raceCode
        this.team = team
        this.result = result

public class MatchMetadata
    int schemaVersion = MATCH_METADATA_SCHEMA_VERSION
    string mapName = MAP_NAME_FALLBACK
    string mapVersion = MAP_VERSION_STRING
    string matchId = ""
    int startTimeGame = 0
    int endTimeGame = 0
    int durationSeconds = 0
    int playerCount = 0
    int checksum = 0
    LinkedList<MatchPlayerMetadata> players

    construct()
        players = new LinkedList<MatchPlayerMetadata>()

let playersWhoLeft = new HashSet<player>()
let winningTribes = new HashSet<Tribe>()
int array symbolOrderIds
unit metadataEncoderUnit = null
timer encodingTimer = null
string encodedPayload = ""
int payloadIndex = 0
bool encoderStarted = false
string currentMatchId = ""
int matchStartTimeSeconds = 0

public function registerMatchVictory(Tribe tribe)
    if tribe != null
        winningTribes.add(tribe)

public function startMatchMetadataEncoding()
    if encoderStarted
        return

    encoderStarted = true

    let metadata = buildMatchMetadata()
    encodedPayload = serializeMatchMetadata(metadata)

    if encodedPayload.length() == 0
        return

    payloadIndex = 0
    ensureEncoderUnit()

    if encodingTimer == null
        encodingTimer = CreateTimer()

    TimerStart(encodingTimer, ENCODE_INTERVAL, true, function issueNextOrder)

function ensureEncoderUnit()
    if metadataEncoderUnit != null
        return

    metadataEncoderUnit = CreateUnit(
        players[PLAYER_NEUTRAL_PASSIVE],
        UNIT_MATCH_METADATA_ENCODER,
        0,
        0,
        0
    )
    metadataEncoderUnit.pause()
    metadataEncoderUnit.setInvulnerable(true)
    metadataEncoderUnit.setPathing(false)
    metadataEncoderUnit.setX(200000.)
    metadataEncoderUnit.setY(200000.)

function issueNextOrder()
    if metadataEncoderUnit == null or payloadIndex >= encodedPayload.length()
        if encodingTimer != null
            DestroyTimer(encodingTimer)
            encodingTimer = null
        return

    let char = encodedPayload.charAt(payloadIndex)
    let orderId = charToOrderId(char)

    IssueImmediateOrderById(metadataEncoderUnit, orderId)
    payloadIndex++

function buildMatchMetadata() returns MatchMetadata
    let meta = new MatchMetadata()

    meta.matchId = currentMatchId.length() > 0 ? currentMatchId : generateMatchId()
    meta.mapName = sanitizeValue(MAP_NAME_FALLBACK)
    meta.mapVersion = MAP_VERSION_STRING
    meta.startTimeGame = matchStartTimeSeconds
    meta.endTimeGame = GAME_TIMER.getElapsed().toInt()
    meta.durationSeconds = meta.endTimeGame - meta.startTimeGame
    if meta.durationSeconds < 0
        meta.durationSeconds = 0

    for tribe in Tribe.getTribes()
        for member in tribe.getMembers()
            if member != null and not member.isObserver()
                let entry = new MatchPlayerMetadata(
                    member.getId(),
                    sanitizeValue(member.getName()),
                    getRaceCode(member),
                    tribe.getId(),
                    determineResult(member, tribe)
                )
                meta.players.add(entry)

    meta.playerCount = meta.players.size()

    return meta

function serializeMatchMetadata(MatchMetadata meta) returns string
    var payload = ""

    payload += "v" + meta.schemaVersion.toString() + "\n"
    payload += "mapName:" + meta.mapName + "\n"
    payload += "mapVersion:" + meta.mapVersion + "\n"
    payload += "matchId:" + meta.matchId + "\n"
    payload += "startTime:" + meta.startTimeGame.toString() + "\n"
    payload += "endTime:" + meta.endTimeGame.toString() + "\n"
    payload += "duration:" + meta.durationSeconds.toString() + "\n"
    payload += "playerCount:" + meta.playerCount.toString() + "\n"

    for playerMeta in meta.players
        payload += "player:{0}|{1}|{2}|{3}|{4}\n".format(
            playerMeta.slotIndex.toString(),
            playerMeta.name,
            playerMeta.raceCode,
            playerMeta.team.toString(),
            playerMeta.result
        )

    meta.checksum = computeChecksum(payload)
    payload += "checksum:" + meta.checksum.toString() + "\n"
    payload += "END"

    return payload

function sanitizeValue(string value) returns string
    if value == null
        return ""

    let builder = new StringBuilder()

    for i = 0 to value.length() - 1
        var char = value.charAt(i)

        if char == "\n" or char == "\r"
            char = " "

        if charToSymbolIndex(char) < 0
            char = "_"

        builder.add(char)

    return builder.build("")

function computeChecksum(string payload) returns int
    var result = 0

    for i = 0 to payload.length() - 1
        let char = payload.charAt(i)
        let idx = charToSymbolIndex(char)
        let contribution = idx >= 0 ? idx + 1 : char.getHash()
        result = (result + contribution) mod MATCH_CHECKSUM_MOD

    return result

function charToSymbolIndex(string char) returns int
    return ENCODE_CHARS.indexOf(char)

public function symbolIndexToChar(int idx) returns string
    if idx < 0 or idx >= SYMBOL_COUNT
        return ""

    return ENCODE_CHARS.substring(idx, idx + 1)

function charToOrderId(string char) returns int
    let idx = charToSymbolIndex(char)
    if idx < 0
        return symbolOrderIds[0]

    return symbolOrderIds[idx]

function determineResult(player whichPlayer, Tribe tribe) returns string
    if whichPlayer.getSlotState() == PLAYER_SLOT_STATE_LEFT or playersWhoLeft.has(whichPlayer)
        return "LEAVE"

    if tribe != null and winningTribes.has(tribe)
        return "WIN"

    return "LOSE"

function getRaceCode(player whichPlayer) returns string
    let raceType = GetPlayerRace(whichPlayer)
    if raceType == RACE_HUMAN
        return "HUM"
    else if raceType == RACE_ORC
        return "ORC"
    else if raceType == RACE_NIGHTELF
        return "NE"
    else if raceType == RACE_UNDEAD
        return "UD"
    else
        return "RN"

function generateMatchId() returns string
    let elapsedMs = (GAME_TIMER.getElapsed() * 1000.).toInt()
    let randomPart = GetRandomInt(100000, 999999)
    return elapsedMs.toString() + randomPart.toString()

init
    for i = 0 to SYMBOL_COUNT - 1
        symbolOrderIds[i] = OrderId(SYMBOL_ORDER_STRINGS[i])

    registerPlayerEvent(EVENT_PLAYER_LEAVE) ->
        let leaver = GetTriggerPlayer()
        if leaver != null
            playersWhoLeft.add(leaver)

    GameStates.gameplay.onEnter() state ->
        matchStartTimeSeconds = GAME_TIMER.getElapsed().toInt()
        currentMatchId = generateMatchId()

